/**
 * Tupaia
 * Copyright (c) 2017 - 2021 Beyond Essential Systems Pty Ltd
 */

import assert from 'assert';

export class ChangeHandler {
  /**
   * A map of change translators by record type. Each translator can alter the change details that
   * queued and scheduled for handling at a later stage, when changes stop coming through.
   *
   * If no translator is defined for the record type, then the `changeDetails` generated by the db
   * will be simply added to the change queue
   *
   * @protected
   * @type {Record<string, Function>}
   */
  changeTranslators = {};

  /**
   * A map of change handlers by record type. Each handler will be used to process queued changes
   * of that type
   *
   * @protected
   * @type {Record<string, Function>}
   */
  changeHandlers = {};

  /**
   * Wait 1 sec after changes before handling the change queue, to avoid double-up.
   * Can override in child classes to fine-tune the timing of queue handling
   *
   * @protected
   */
  debounceTime = 1000; // ms

  /**
   * @type {Record<string, Array>} Changes by record type
   */
  changeQueue = {};

  scheduledTimeout = null;

  scheduledPromise = null;

  scheduledPromiseResolve = null;

  scheduledPromiseReject = null;

  activePromise = null;

  changeHandlerCancellers = [];

  constructor(models) {
    this.models = models;
  }

  setDebounceTime(debounceTime) {
    this.debounceTime = debounceTime;
  }

  listenForChanges() {
    this.changeHandlerCancellers = Object.keys(this.changeHandlers).map(recordType => {
      this.changeQueue[recordType] = [];
      const changeTranslator =
        this.changeTranslators[recordType] || (changeDetails => [changeDetails]);

      const translateAndSchedule = async changeDetails => {
        this.changeQueue[recordType].push(...changeTranslator(changeDetails));
        // Changes are scheduled to be handled as a batch at a later stage
        return this.scheduleChangeQueueHandler(recordType);
      };
      return this.models[recordType].addChangeHandler(translateAndSchedule);
    });
  }

  stopListeningForChanges() {
    this.changeHandlerCancellers.forEach(c => c());
    this.changeHandlerCancellers = [];
  }

  async scheduleChangeQueueHandler(recordType) {
    // wait for any active handler to finish before scheduling a new one
    await this.activePromise;

    // clear any previous scheduled handler, so that we debounce all changes in the same time period
    if (this.scheduledTimeout) {
      clearTimeout(this.scheduledTimeout);
    }

    if (!this.scheduledPromise) {
      this.scheduledPromise = new Promise((resolve, reject) => {
        this.scheduledPromiseResolve = resolve;
        this.scheduledPromiseReject = reject;
      });
    }

    // schedule the handler to execute after an adequate period of debouncing
    this.scheduledTimeout = setTimeout(() => {
      this.activePromise = this.handleChangeQueue(recordType);
    }, this.debounceTime);

    return this.scheduledPromise;
  }

  handleChangeQueue = async recordType => {
    // remove timeout so any changes added now get scheduled anew
    this.scheduledTimeout = null;
    this.scheduledPromise = null;

    const changeQueueHandler = this.changeHandlers[recordType];
    assert.ok(changeQueueHandler);

    const queuedChanges = this.changeQueue[recordType];
    this.changeQueue[recordType] = [];

    try {
      await changeQueueHandler(queuedChanges);
    } catch (error) {
      this.changeQueue[recordType] = queuedChanges.concat(this.changeQueue[recordType]);
      throw error;
    }
    this.scheduledPromiseResolve();
  };
}
